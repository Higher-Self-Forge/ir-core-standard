{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://ir-standard.org/schemas/v1.0/constitution.schema.json",
  "$comment": "IR v1.0 Core Standard | Copyright (c) 2026 Higher Self Forge Ltd (UK) - Owner/Rights Holder | Research & field lab: Qori Labs (Peru) | CC-BY-NC-SA-4.0",
  "title": "IR Constitution Manifest",
  "description": "A manifest declaring enforceable principles, boundaries, and consent triggers governing an IR deployment. Constitutions SHOULD be compiled into an internal enforcement representation; `compiled_hash` attests to that compilation result. Proofs/signatures MAY follow W3C Verifiable Credentials proof patterns.",
  "type": "object",
  "additionalProperties": false,
  "required": [
    "version",
    "name",
    "authority",
    "principles",
    "boundaries",
    "consent_triggers"
  ],
  "properties": {
    "id": {
      "type": "string",
      "description": "Optional constitution identifier (URI or UUID). Implementations SHOULD treat this as stable across republished copies."
    },
    "version": {
      "type": "string",
      "pattern": "^1\\.0(\\.\\d+)?$",
      "description": "Schema/standard version. For IR v1.0, this MUST start with '1.0'."
    },
    "name": {
      "type": "string",
      "minLength": 1,
      "description": "Human-readable constitution name."
    },
    "authority": {
      "type": "string",
      "minLength": 1,
      "description": "Issuing authority identifier (e.g., community council DID, legal entity URI, or governance namespace)."
    },
    "principles": {
      "type": "array",
      "minItems": 1,
      "description": "Core principles that constrain system behavior and decision-making.",
      "items": {
        "$ref": "#/$defs/Principle"
      }
    },
    "boundaries": {
      "type": "array",
      "minItems": 1,
      "description": "Boundary references or embedded Boundary Card objects. Boundary Cards are the source of truth; inline copies are discouraged to avoid drift.",
      "items": {
        "oneOf": [
          {
            "$ref": "#/$defs/BoundaryRef"
          },
          {
            "$ref": "#/$defs/BoundaryCardEmbedded"
          }
        ]
      }
    },
    "consent_triggers": {
      "type": "array",
      "minItems": 1,
      "description": "Events or conditions that require new consent or a consent status review (e.g., adding a new dataset, enabling a new model feature, or expanding beneficiaries).",
      "items": {
        "$ref": "#/$defs/ConsentTrigger"
      }
    },
    "valid_from": {
      "type": "string",
      "format": "date-time",
      "description": "Timestamp when this constitution becomes effective."
    },
    "supersedes": {
      "type": "string",
      "description": "Identifier of the prior constitution manifest that this one supersedes."
    },
    "compiled_hash": {
      "type": "string",
      "pattern": "^(?:[A-Fa-f0-9]{64}|z[1-9A-HJ-NP-Za-km-z]+|u[A-Za-z0-9\\-_]+)$",
      "description": "Integrity hash of the compiled/enforcement-ready constitution representation. Implementations SHOULD define and document the canonical compilation procedure to ensure reproducibility."
    },
    "signatures": {
      "type": "array",
      "description": "Array of signatures/proofs attesting to the constitution content and/or compiled_hash.",
      "items": {
        "$ref": "#/$defs/Signature"
      }
    },
    "proof": {
      "description": "Optional W3C VC-style proof object or array. Provided for compatibility with ecosystems that expect a `proof` field.",
      "oneOf": [
        {
          "$ref": "#/$defs/Signature"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Signature"
          },
          "minItems": 1
        }
      ]
    },
    "metadata": {
      "type": "object",
      "description": "Optional metadata (e.g., locale, adoption meeting references, publication notes).",
      "additionalProperties": true
    }
  },
  "$defs": {
    "Principle": {
      "title": "Constitution Principle",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "id",
        "name",
        "rule",
        "enforcement"
      ],
      "properties": {
        "id": {
          "type": "string",
          "minLength": 1,
          "description": "Stable principle identifier (e.g., 'P-01')."
        },
        "name": {
          "type": "string",
          "minLength": 1,
          "description": "Short principle name."
        },
        "rule": {
          "type": "string",
          "minLength": 1,
          "description": "Normative rule text describing expected behavior."
        },
        "enforcement": {
          "type": "string",
          "minLength": 1,
          "description": "Enforcement mechanism or process (e.g., technical control, review gate, or council approval)."
        }
      }
    },
    "BoundaryRef": {
      "title": "Boundary Card Reference",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "card_id"
      ],
      "properties": {
        "card_id": {
          "type": "string",
          "minLength": 1,
          "description": "Boundary Card identifier (UUID/URI)."
        },
        "content_hash": {
          "type": "string",
          "pattern": "^(?:[A-Fa-f0-9]{64}|z[1-9A-HJ-NP-Za-km-z]+|u[A-Za-z0-9\\-_]+)$",
          "description": "Optional integrity hash of the referenced Boundary Card content."
        },
        "adopted_by_decision_id": {
          "type": "string",
          "description": "Optional decision ID that approved/adopted this boundary."
        }
      }
    },
    "BoundaryCardEmbedded": {
      "title": "Boundary Card (Embedded)",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "card_id",
        "boundary_type",
        "statement",
        "enforcement_mechanism"
      ],
      "properties": {
        "card_id": {
          "type": "string",
          "minLength": 1,
          "description": "Unique boundary card identifier (UUID/URI)."
        },
        "boundary_type": {
          "type": "string",
          "enum": [
            "technical",
            "social",
            "legal",
            "cultural",
            "ethical"
          ],
          "description": "Boundary category."
        },
        "statement": {
          "type": "string",
          "minLength": 1,
          "description": "Human-legible boundary statement describing what MUST NOT happen or what MUST always happen."
        },
        "enforcement_mechanism": {
          "type": "string",
          "minLength": 1,
          "description": "How the boundary is enforced (runtime control, process gate, legal instrument, audit check)."
        },
        "rationale": {
          "type": "string",
          "description": "Optional rationale explaining why the boundary exists (community values, risk mitigation, legal requirements)."
        },
        "exceptions": {
          "type": "array",
          "description": "Optional exceptions. Exceptions SHOULD be narrow, documented, and require explicit approval.",
          "items": {
            "type": "object",
            "additionalProperties": false,
            "required": [
              "condition",
              "approval_required"
            ],
            "properties": {
              "condition": {
                "type": "string",
                "minLength": 1,
                "description": "Condition under which the exception applies."
              },
              "approval_required": {
                "type": "string",
                "minLength": 1,
                "description": "Who must approve (e.g., 'council', 'two_custodians')."
              },
              "expiry": {
                "type": "string",
                "format": "date-time",
                "description": "Optional expiry timestamp for the exception."
              }
            }
          }
        },
        "review_date": {
          "type": "string",
          "format": "date",
          "description": "Optional next review date for reaffirmation or amendment."
        },
        "approved_by": {
          "type": "string",
          "description": "Optional identifier of approving body/person (DID/URI)."
        },
        "linked_controls": {
          "type": "array",
          "description": "Optional list of linked technical controls (control IDs, policy engine rules, test case references).",
          "items": {
            "type": "string",
            "minLength": 1
          }
        },
        "signatures": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Signature"
          },
          "description": "Optional signatures/proofs over the boundary card."
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true,
          "description": "Optional metadata (locale, adoption references, UI tags)."
        }
      }
    },
    "ConsentTrigger": {
      "title": "Consent Trigger",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "id",
        "trigger",
        "required_action"
      ],
      "properties": {
        "id": {
          "type": "string",
          "minLength": 1,
          "description": "Stable trigger identifier (e.g., 'CT-03')."
        },
        "trigger": {
          "type": "string",
          "minLength": 1,
          "description": "Description of the event/condition that triggers consent review (e.g., 'enable_new_feature:predictive_yield')."
        },
        "required_action": {
          "type": "string",
          "minLength": 1,
          "description": "Required action upon trigger (e.g., 'obtain_new_FPIC', 'council_review', 'pause_processing')."
        },
        "scope_hint": {
          "type": "string",
          "description": "Optional hint to link trigger to consent scope categories (data types, features, beneficiaries)."
        }
      }
    },
    "Signature": {
      "title": "Signature / Proof",
      "description": "A compact signature/proof object aligned with common W3C Verifiable Credentials proof fields. Implementations MAY use JWS, Linked Data Proofs, or other mechanisms. When present, fields SHOULD be sufficient to verify the attestation.",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "type",
        "created",
        "verificationMethod",
        "proofPurpose"
      ],
      "anyOf": [
        {
          "required": [
            "jws"
          ]
        },
        {
          "required": [
            "proofValue"
          ]
        }
      ],
      "properties": {
        "type": {
          "type": "string",
          "minLength": 1,
          "description": "Signature/proof suite identifier (e.g., 'Ed25519Signature2020', 'JsonWebSignature2020', or 'Jws2020')."
        },
        "created": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the proof was created (RFC 3339 / ISO 8601)."
        },
        "verificationMethod": {
          "type": "string",
          "minLength": 1,
          "description": "A URI identifying the verification method (often a DID URL)."
        },
        "proofPurpose": {
          "type": "string",
          "enum": [
            "assertionMethod",
            "authentication",
            "capabilityInvocation",
            "capabilityDelegation"
          ],
          "description": "Purpose of the proof, per VC patterns."
        },
        "domain": {
          "type": "string",
          "description": "Optional domain separation string to prevent cross-protocol replay."
        },
        "challenge": {
          "type": "string",
          "description": "Optional challenge/nonce to prevent replay."
        },
        "jws": {
          "type": "string",
          "description": "Detached or embedded JWS representation, if applicable."
        },
        "proofValue": {
          "type": "string",
          "description": "Base58/base64 proof value, if applicable (alternative to JWS)."
        },
        "cryptosuite": {
          "type": "string",
          "description": "Cryptographic suite identifier for data integrity proofs, if applicable."
        }
      }
    }
  },
  "examples": [
    {
      "id": "urn:ir:constitution:cusco-ayllu-2026-01",
      "version": "1.0.0",
      "name": "Ayllu Cusco IR Constitution",
      "authority": "did:web:ayllu.example.org#council",
      "valid_from": "2026-01-05T00:00:00Z",
      "principles": [
        {
          "id": "P-01",
          "name": "Collective Benefit First",
          "rule": "System deployments MUST demonstrate measurable community benefit and MUST NOT prioritize external optimization over local wellbeing.",
          "enforcement": "Council gate: benefit plan approval required before enabling production inference."
        }
      ],
      "boundaries": [
        {
          "card_id": "urn:ir:boundary:cusco-ayllu:B-01",
          "content_hash": "b1b2c3d4e5f60718293a4b5c6d7e8f901234567890abcdef1234567890abcdea",
          "adopted_by_decision_id": "IR-GOV-DEC-2026-001"
        }
      ],
      "consent_triggers": [
        {
          "id": "CT-01",
          "trigger": "new_dataset:on-farm_soil_samples",
          "required_action": "obtain_new_FPIC",
          "scope_hint": "data_categories.soil"
        }
      ],
      "compiled_hash": "a1b2c3d4e5f60718293a4b5c6d7e8f901234567890abcdef1234567890abcdef",
      "signatures": [
        {
          "type": "Ed25519Signature2020",
          "created": "2026-01-05T18:30:00Z",
          "verificationMethod": "did:web:ayllu.example.org#council-key-1",
          "proofPurpose": "assertionMethod",
          "proofValue": "z2uExampleCouncilSignature"
        }
      ]
    }
  ]
}
